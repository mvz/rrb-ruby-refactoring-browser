#!/usr/bin/env ruby
require 'rrb/emacs_interface'

def print_usage

  print "\
Usage: rrb refactoring-type refactoring-parameter io-type

  refactoring-type
    * rename-local-variable Class#method old_var new_var
    * rename-method-all old_method new_method

  io-type
    * --stdin-stdout
    * --filein-overwrite FILES..
    * --filein-stdout FILES..
"
end

def split_method_name( str )
  a, b = str.split( /#/ )
  return a.split(/::/), b
end

if $0 == __FILE__ then

  if ARGV.size == 0 then
    print_usage
    exit
  end

  begin

    #  analyze options
    refactor_type = ARGV.shift
    case refactor_type
    when 'rename-local-variable'
      namespace, method_name = split_method_name ARGV.shift
      old_var = ARGV.shift
      new_var = ARGV.shift
    when 'rename-method-all'
      old_method = ARGV.shift
      new_method = ARGV.shift
    end

    case ARGV.shift
    when '--stdin-stdout', nil
      script = RRB::Script.new_from_io( STDIN )
      output = proc{ script.result_to_io( STDOUT ) }
    when '--filein-overwrite'      
      script = RRB::Script.new_from_filenames( ARGV )
      output = proc{ script.result_overwrite_file }
    when '--filein-stdout'
      script = RRB::Script.new_from_filenames( ARGV )
      output = proc{ script.result_to_io( STDOUT ) }
    end

    # refactoring
    case refactor_type
    when 'rename-local-variable'
      unless script.rename_local_var?( namespace, method_name, old_var, new_var )
	STDERR << "REJECTED\n"
	exit 1
      end
      script.rename_local_var( namespace, method_name, old_var, new_var )
      output.call
    when 'rename-method-all'
      unless script.rename_method_all?( old_method, new_method )
	STDERR << "REJECTED\n"
	exit 1
      end
      script.rename_method_all( old_method, new_method )
      output.call
    end
    
  rescue
    STDERR << "ERROR: exeption raised: #{$!.message}\n"
    exit 2
  end
    
  
end
